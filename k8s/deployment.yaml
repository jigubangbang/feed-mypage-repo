apiVersion: apps/v1
kind: Deployment
metadata:
  name: feed-mypage-repo-deployment # Deployment 리소스의 이름을 레포지토리 이름으로 지정
  labels:
    app: feed-mypage-repo # 이 Deployment를 식별하기 위한 라벨
spec:
  replicas: 1 # 실행할 Pod의 복제본 수. 번들 컨테이너이므로 1개가 일반적.
  selector:
    matchLabels:
      app: feed-mypage-repo # 이 Deployment가 관리할 Pod를 선택하는 라벨 셀렉터
  template: # 생성될 Pod의 명세 (템플릿)
    metadata:
      labels:
        app: feed-mypage-repo # 생성될 Pod에 적용될 라벨 (위 selector와 일치해야 함)
    spec:
      # 초기화 컨테이너: Config Server와 Eureka Server가 준비될 때까지 대기합니다.
      # 이 번들 내의 모든 서비스가 이 두 인프라 서비스에 의존하므로 Init Container로 설정합니다.
      initContainers:
        - name: wait-for-config-server
          image: curlimages/curl:latest # 경량 curl 이미지 사용
          command:
            - 'sh'
            - '-c'
            - 'until curl -s http://config-server:8888/actuator/health; do echo waiting for config-server; sleep 5; done;'
        - name: wait-for-eureka
          image: curlimages/curl:latest # 경량 curl 이미지 사용
          command:
            - 'sh'
            - '-c'
            - 'until curl -s http://eureka-server:8761/actuator/health; do echo waiting for eureka-server; sleep 10; done;'
      containers:
      - name: feed-mypage-repo-container # Pod 내에서 실행될 컨테이너의 이름을 레포지토리 이름으로 변경
        image: __ECR_IMAGE_FULL_PATH__ # 이전에 빌드할 번들 Docker 이미지 경로로 변경 필요
        ports:
        # 번들 컨테이너 내에서 실행되는 모든 서비스의 포트를 명시합니다.
        - containerPort: 8084 # Feed Service 포트 (Dockerfile의 EXPOSE와 일치)
        - containerPort: 8085 # Mypage Service 포트 (Dockerfile의 EXPOSE와 일치)
        env:
          # Spring Cloud Config Server URL (Kubernetes Service 이름 사용)
          - name: SPRING_CLOUD_CONFIG_URI
            value: "http://config-server:8888"
          # Eureka Server URL (Kubernetes Service 이름 사용)
          - name: EUREKA_CLIENT_SERVICEURL_DEFAULTZONE
            value: "http://eureka-server:8761/eureka/"
          - name: SPRING_PROFILES_ACTIVE
            value: "production" # Dockerfile에서 설정한 "production" 프로파일 사용
          # Actuator 엔드포인트 노출 설정 (번들 내 모든 서비스에 공통 적용)
          - name: MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE
            value: "health,liveness,readiness"
        resources:
          limits:
            # 두 서비스가 함께 실행되므로 CPU/메모리 상한 조정 (각 서비스 500m/1536Mi 가정)
            cpu: "1000m" # (500m * 2)
            memory: "3072Mi" # (1536Mi * 2)
          requests:
            # 요청량도 각 서비스의 요청량 합산 (각 서비스 300m/768Mi 가정)
            cpu: "600m"   # (300m * 2)
            memory: "1536Mi" # (768Mi * 2)
        # livenessProbe와 readinessProbe는 번들 내의 특정 서비스 포트를 가리킬 수밖에 없습니다.
        # 여기서는 Feed Service (8084)를 대표로 사용합니다.
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness # Spring Boot 2.x 이상 엔드포인트 사용 권장
            port: 8084 # Feed Service의 포트 (Dockerfile의 EXPOSE와 일치)
          initialDelaySeconds: 90 # 컨테이너 시작 후 프로브 시작까지 대기 시간 (두 서비스 모두 시작될 시간 고려)
          periodSeconds: 20       # 프로브 주기
          timeoutSeconds: 10      # 프로브 응답 대기 시간
          failureThreshold: 3     # 실패 횟수
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness # Spring Boot 2.x 이상 엔드포인트 사용 권장
            port: 8084 # Feed Service의 포트 (Dockerfile의 EXPOSE와 일치)
          initialDelaySeconds: 60 # 컨테이너 시작 후 프로브 시작까지 대기 시간
          periodSeconds: 15
          timeoutSeconds: 10
          failureThreshold: 3
